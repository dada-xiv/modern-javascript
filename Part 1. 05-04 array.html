<!DOCTYPE HTML>
<html>
<head>
</head>
<body>
<div id="log"></div>
<script>
let printID = "log";

function print(arg1, arg2){
	let elmId = '';
	let str = '';

	if(arguments.length > 1){
		elmId = document.getElementById(arg1);
		str = arg2;
	}else{
		elmId = document.getElementById(printID);
		str = arg1;
	}
	
	elmId.tagName === "INPUT" ? elmId.value=str : elmId.innerHTML+=`${str}<br>`;
}

function setPrintID(str){
	printID = str;
}

/* 
Declaration of an empty array:

If new Array is called with a single argument which is a number, then it creates an arry without items, but with the given length.
*/

let arr = [];
//let arr = new Array(); 와 같다

arr = new Array(3); //item이 없는 크기 3의 배열이 생긴다.
print(arr);
print(arr.length);

//An array can store elements of any type:
arr = ['Apple', {name:'John'}, true, function(){return 'hello';}];

print(arr[3]());


let fruits = ["Apple", "Orange", "Plum"]; //plum : 자두
let fruits2 = new Array(fruits);
print("copy of the given array :" + fruits2);

print(fruits[fruits.length-1]); //last elements of array
print(fruits.at(-1));

// arr.at(i)는 음수일 때는 뒤에서부터 세는 것이고, 0 또는 양수일 때는 arr[i]와 같다.

/*
pop/push와 shift/unshift:

pop은 맨 뒤의 element를 가져오고, 배열에서 없앤다.
push는 element를 배열의 맨 뒤에 추가한다.

cf) stack의 경우는 마지막으로 넣어진 것이 처음 나오고(last-in-first-out), queue는 처음 넣은 게 처음 나온다(first-in-first-out).
*/
print("* pop/push: " + fruits);
print(fruits);

print(fruits.pop());
print(fruits);

//fruits.pop() returns the last element and modify the array by removing it.
//fruits.at(-1) just returns the last element and doesn't modify the array.

fruits.push("Pear1", "Pear2");
//fruits[fruits.length] = "Pear"; 와 같다.

print(fruits);


/*
shift는 맨 앞의 element를 가져오고, 배열에서 없앤다.
unshift는 배열의 맨 앞에 element를 추가한다.
*/
fruits = ["Orange", "Pear"];
print("* shift/unshift: " + fruits);
print(fruits);

print(fruits.shift());
print(fruits);

fruits.unshift("Apple1", "Apple2");
print(fruits);

/*
An array is copied by reference: 
*/
print("copied by reference");
let arr1 = ["Banana"];
let arr2 = arr1; //copy by reference (two variables reference the same array)

print(arr1 == arr2); //true
arr2.push("Pear"); //동시에 삽입된다

print(`arr1 = ${arr1}<br> arr2 = ${arr2}`);

//Two objects are equal == only if they’re references to the same object.
print(arr1 == arr2); //true
print([0] == [0]); //false

//The strict comparison === is even simpler, as it doesn’t convert types.
print(arr1 === arr2); //true
print([0] === [0]); //false

// array는 기본적으로 object이기 때문에, object에 가해지는 연산이 모두 가능하다. 그러나 그렇게 다루지 않는 것이 좋다.

// push/pop은 빠르고, shift/unshift는 느리다.

/*
If we increase .length manually, nothing happens. But if we decrease it, the array is truncated. The process is irreversible.

So, the simplest way to clear the array is arr.length = 0;
*/

//multidimensional arrays:
print("multidimensional :");

let A = [
	[1, 2, 3],
	[4, 5, 6],
	[7, 8, 9]
];
print(A);
print(A[0][0]);
print(A[1][1]);

//toString with array:

arr = [1, 2, 3];
print(String(arr));
print(String(arr)==='1,2,3'); //true


</script>
</body>
</html>